// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: checkin.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAllCheckins = `-- name: CountAllCheckins :one
SELECT COUNT(*)
FROM checkin
`

func (q *Queries) CountAllCheckins(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllCheckins)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAllCheckinsByDate = `-- name: CountAllCheckinsByDate :one
SELECT COUNT(*)
FROM checkin
WHERE record_date >= $1
  AND record_date <= $2
  AND (tag = $3 OR $3 = '')
`

type CountAllCheckinsByDateParams struct {
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
	Tag       string      `json:"tag"`
}

func (q *Queries) CountAllCheckinsByDate(ctx context.Context, arg CountAllCheckinsByDateParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAllCheckinsByDate, arg.StartDate, arg.EndDate, arg.Tag)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCheckin = `-- name: CreateCheckin :one
INSERT INTO checkin (duration,
                     start_time,
                     record_date,
                     tag,
                     activities)
VALUES ($1,
        $2,
        $3,
        $4,
        $5)
RETURNING id, created, modified, duration, start_time, record_date, tag, activities
`

type CreateCheckinParams struct {
	Duration   float64            `json:"duration"`
	StartTime  pgtype.Timestamptz `json:"start_time"`
	RecordDate pgtype.Date        `json:"record_date"`
	Tag        string             `json:"tag"`
	Activities string             `json:"activities"`
}

func (q *Queries) CreateCheckin(ctx context.Context, arg CreateCheckinParams) (Checkin, error) {
	row := q.db.QueryRow(ctx, createCheckin,
		arg.Duration,
		arg.StartTime,
		arg.RecordDate,
		arg.Tag,
		arg.Activities,
	)
	var i Checkin
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Duration,
		&i.StartTime,
		&i.RecordDate,
		&i.Tag,
		&i.Activities,
	)
	return i, err
}

const deleteCheckin = `-- name: DeleteCheckin :exec
DELETE
FROM checkin
WHERE id = $1
`

func (q *Queries) DeleteCheckin(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteCheckin, id)
	return err
}

const getCheckin = `-- name: GetCheckin :one
SELECT id,
       created,
       modified,
       duration,
       CONCAT_WS(
               ':',
               LPAD(EXTRACT(HOUR FROM start_time)::TEXT, 2, '0'),
               LPAD(EXTRACT(MINUTE FROM start_time)::TEXT, 2, '0')
       ) AS start_time,
       record_date,
       tag,
       activities
FROM checkin
WHERE id = $1
LIMIT 1
`

type GetCheckinRow struct {
	ID         string             `json:"id"`
	Created    pgtype.Timestamptz `json:"created"`
	Modified   pgtype.Timestamptz `json:"modified"`
	Duration   float64            `json:"duration"`
	StartTime  string             `json:"start_time"`
	RecordDate pgtype.Date        `json:"record_date"`
	Tag        string             `json:"tag"`
	Activities string             `json:"activities"`
}

func (q *Queries) GetCheckin(ctx context.Context, id string) (GetCheckinRow, error) {
	row := q.db.QueryRow(ctx, getCheckin, id)
	var i GetCheckinRow
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Duration,
		&i.StartTime,
		&i.RecordDate,
		&i.Tag,
		&i.Activities,
	)
	return i, err
}

const getCheckinStatsByDate = `-- name: GetCheckinStatsByDate :many
SELECT tag, ROUND(SUM(duration)::NUMERIC, 5)::FLOAT AS duration
FROM checkin
WHERE record_date >= $1
  AND record_date <= $2
GROUP BY tag
ORDER BY duration
`

type GetCheckinStatsByDateParams struct {
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

type GetCheckinStatsByDateRow struct {
	Tag      string  `json:"tag"`
	Duration float64 `json:"duration"`
}

func (q *Queries) GetCheckinStatsByDate(ctx context.Context, arg GetCheckinStatsByDateParams) ([]GetCheckinStatsByDateRow, error) {
	rows, err := q.db.Query(ctx, getCheckinStatsByDate, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCheckinStatsByDateRow
	for rows.Next() {
		var i GetCheckinStatsByDateRow
		if err := rows.Scan(&i.Tag, &i.Duration); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCheckinStatsByDateTag = `-- name: GetCheckinStatsByDateTag :many
SELECT ROUND(SUM(duration)::NUMERIC, 5)::FLOAT AS duration, activities
FROM checkin
WHERE record_date >= $1
  AND record_date <= $2
  AND tag = $3
GROUP BY activities
ORDER BY duration
`

type GetCheckinStatsByDateTagParams struct {
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
	Tag       string      `json:"tag"`
}

type GetCheckinStatsByDateTagRow struct {
	Duration   float64 `json:"duration"`
	Activities string  `json:"activities"`
}

func (q *Queries) GetCheckinStatsByDateTag(ctx context.Context, arg GetCheckinStatsByDateTagParams) ([]GetCheckinStatsByDateTagRow, error) {
	rows, err := q.db.Query(ctx, getCheckinStatsByDateTag, arg.StartDate, arg.EndDate, arg.Tag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCheckinStatsByDateTagRow
	for rows.Next() {
		var i GetCheckinStatsByDateTagRow
		if err := rows.Scan(&i.Duration, &i.Activities); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllCheckinsByDate = `-- name: ListAllCheckinsByDate :many
SELECT id,
       created,
       modified,
       ROUND(duration::NUMERIC, 5)::FLOAT AS duration,
       CONCAT_WS(
               ':',
               LPAD(EXTRACT(HOUR FROM start_time)::TEXT, 2, '0'),
               LPAD(EXTRACT(MINUTE FROM start_time)::TEXT, 2, '0')
       )                                  AS start_time,
       record_date,
       tag,
       activities
FROM checkin
WHERE record_date >= $1
  AND record_date <= $2
`

type ListAllCheckinsByDateParams struct {
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

type ListAllCheckinsByDateRow struct {
	ID         string             `json:"id"`
	Created    pgtype.Timestamptz `json:"created"`
	Modified   pgtype.Timestamptz `json:"modified"`
	Duration   float64            `json:"duration"`
	StartTime  string             `json:"start_time"`
	RecordDate pgtype.Date        `json:"record_date"`
	Tag        string             `json:"tag"`
	Activities string             `json:"activities"`
}

func (q *Queries) ListAllCheckinsByDate(ctx context.Context, arg ListAllCheckinsByDateParams) ([]ListAllCheckinsByDateRow, error) {
	rows, err := q.db.Query(ctx, listAllCheckinsByDate, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllCheckinsByDateRow
	for rows.Next() {
		var i ListAllCheckinsByDateRow
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Duration,
			&i.StartTime,
			&i.RecordDate,
			&i.Tag,
			&i.Activities,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCheckins = `-- name: ListCheckins :many
SELECT id,
       created,
       modified,
       ROUND(duration::NUMERIC, 5)::FLOAT AS duration,
       CONCAT_WS(
               ':',
               LPAD(EXTRACT(HOUR FROM start_time)::TEXT, 2, '0'),
               LPAD(EXTRACT(MINUTE FROM start_time)::TEXT, 2, '0')
       )                                  AS start_time,
       record_date,
       tag,
       activities
FROM checkin
WHERE record_date >= $1
  AND record_date <= $2
  AND (tag = $3 OR $3 = '')
ORDER BY start_time DESC
LIMIT 10 OFFSET $4
`

type ListCheckinsParams struct {
	StartDate  pgtype.Date `json:"start_date"`
	EndDate    pgtype.Date `json:"end_date"`
	Tag        string      `json:"tag"`
	PageOffset int32       `json:"page_offset"`
}

type ListCheckinsRow struct {
	ID         string             `json:"id"`
	Created    pgtype.Timestamptz `json:"created"`
	Modified   pgtype.Timestamptz `json:"modified"`
	Duration   float64            `json:"duration"`
	StartTime  string             `json:"start_time"`
	RecordDate pgtype.Date        `json:"record_date"`
	Tag        string             `json:"tag"`
	Activities string             `json:"activities"`
}

func (q *Queries) ListCheckins(ctx context.Context, arg ListCheckinsParams) ([]ListCheckinsRow, error) {
	rows, err := q.db.Query(ctx, listCheckins,
		arg.StartDate,
		arg.EndDate,
		arg.Tag,
		arg.PageOffset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCheckinsRow
	for rows.Next() {
		var i ListCheckinsRow
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Duration,
			&i.StartTime,
			&i.RecordDate,
			&i.Tag,
			&i.Activities,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many
SELECT DISTINCT tag AS tags
FROM checkin
`

func (q *Queries) ListTags(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, listTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tags string
		if err := rows.Scan(&tags); err != nil {
			return nil, err
		}
		items = append(items, tags)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTextLog = `-- name: ListTextLog :many
SELECT record_date,
       tag,
       ROUND(SUM(duration)::NUMERIC, 5)::FLOAT AS duration,
       activities,
       MIN(start_time::TIME)                   AS start_time
FROM checkin
WHERE record_date >= $1
  AND record_date <= $2
GROUP BY record_date, tag, activities
ORDER BY record_date, start_time
`

type ListTextLogParams struct {
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

type ListTextLogRow struct {
	RecordDate pgtype.Date `json:"record_date"`
	Tag        string      `json:"tag"`
	Duration   float64     `json:"duration"`
	Activities string      `json:"activities"`
	StartTime  interface{} `json:"start_time"`
}

func (q *Queries) ListTextLog(ctx context.Context, arg ListTextLogParams) ([]ListTextLogRow, error) {
	rows, err := q.db.Query(ctx, listTextLog, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTextLogRow
	for rows.Next() {
		var i ListTextLogRow
		if err := rows.Scan(
			&i.RecordDate,
			&i.Tag,
			&i.Duration,
			&i.Activities,
			&i.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCheckin = `-- name: UpdateCheckin :one
UPDATE checkin
SET duration    = $2,
    start_time  = $3,
    record_date = $4,
    tag         = $5,
    activities  = $6
WHERE id = $1
RETURNING id, created, modified, duration, start_time, record_date, tag, activities
`

type UpdateCheckinParams struct {
	ID         string             `json:"id"`
	Duration   float64            `json:"duration"`
	StartTime  pgtype.Timestamptz `json:"start_time"`
	RecordDate pgtype.Date        `json:"record_date"`
	Tag        string             `json:"tag"`
	Activities string             `json:"activities"`
}

func (q *Queries) UpdateCheckin(ctx context.Context, arg UpdateCheckinParams) (Checkin, error) {
	row := q.db.QueryRow(ctx, updateCheckin,
		arg.ID,
		arg.Duration,
		arg.StartTime,
		arg.RecordDate,
		arg.Tag,
		arg.Activities,
	)
	var i Checkin
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Duration,
		&i.StartTime,
		&i.RecordDate,
		&i.Tag,
		&i.Activities,
	)
	return i, err
}
